# DuelSimulatorについて

## 概要
コンソール上でデュエルを高速に行うためのシミュレータです。

AIの学習にはマスターデュエルの方ではなくこちらを使用することになります。

## 実行手順
### 1.シミュレータ自体の動作確認
まずはpython側の準備なしでCPU同士のデュエルができるかを試してみてください。
1. DuelSimulator.exe があるディレクトリへ移動します
    - エクスプローラーから DuelSimulator.exe があるフォルダを開き、空白部分で **右クリック** → **ターミナルで開く**を選択します。
    - ここではわかりやすさのためにシミュレータの場所で実行していますが、パスを正しく指定できればどこで実行しても構いません。
2. ターミナルで下記のコマンドを実行します。

```
.\DuelSimulator.exe --player_type0 CPU --player_type1 CPU --deck_path0 DeckData\SimpleBE.json --deck_path1 DeckData\SimpleBE.json --log_level 3
```

3. ターミナルにCPU同士がデュエルしているログが流れれば実行に成功しています。

### 2.pythonとの通信確認
シミュレータの動作を確認できたら、pythonとの接続を確認してください。
1. pythonが動くPCでスクリプトを起動します（AIコンテストではシミュレータとは別PCになるかと思います）

例:

```
python udi_simple_v1.py
```

2. シミュレータを起動します。起動手順はCPU同士のデュエルと同じですが、今回はpythonと通信するため下記のコマンドで実行してください。

```
.\DuelSimulator.exe --player_type0 Human --player_type1 CPU --deck_path0 DeckData\SimpleBE.json --deck_path1 DeckData\SimpleBE.json --log_level 3
```

3. シミュレータのターミナルとpython側のターミナルでログが流れていれば実行に成功しています。

## シミュレータの設定について
### 概要
シミュレータでデュエルを行うためには、UDI用の設定に加えてシミュレータで行うデュエル自体にも設定をする必要があります。

設定は**SimulatorSettings.jsonによる指定**と**コマンドラインオプションによる指定**が可能です

### 設定項目について
ここでは、シミュレータで指定可能な各設定項目の意味と使い方を説明します。
設定項目は下記のとおりです。

| 項目名                   | 型            | コマンドラインオプション例               | 説明 |
|--------------------------|--------------|----------------------------------------|-------|
| player_type0             | string       | --player_type0 Human                   | プレイヤー0の種類を指定します。（`Human`か`CPU`） |
| player_type1             | string       | --player_type1 CPU                     | プレイヤー1の種類を指定します。（`Human`か`CPU`） |
| deck_path0               | string       | --deck_path0 DeckData/RoyaleBE.json    | プレイヤー0のデッキをjsonファイルのパスで指定します。 |
| deck_path1               | string       | --deck_path1 DeckData/RoyaleBE.json    | プレイヤー1のデッキをjsonファイルのパスで指定します。 |
| first_player             | int          | --first_player 0                       | 先攻プレイヤーの番号を指定します。 |
| lp0                      | int          | --lp0 8000                             | プレイヤー0の初期LPを設定します。 |
| lp1                      | int          | --lp1 8000                             | プレイヤー1の初期LPを設定します。 |
| hand_num0                | int          | --hand_num0 5                          | プレイヤー0の初期手札の枚数を設定します。 |
| hand_num1                | int          | --hand_num1 5                          | プレイヤー1の初期手札の枚数を設定します。 |
| seed                     | uint         | --seed 0                               | シミュレータで行うデュエルの乱数の初期値を設定します。 |
| log_level                | int          | --log_level 3                          | シミュレータのコンソールに出すログのレベルを設定します。（`1`~`3`） |
| loop_num                 | int          | --loop_num 100                         | シミュレータで行うデュエルの回数を指定します。 |
| randomize_seed           | bool         | --randomize_seed false                 | シミュレータで行うデュエルの乱数の初期値を毎回ランダムにします。 |
| iterate_seed             | bool         | --iterate_seed true                    | シミュレータで行う`i`回目のデュエルの乱数の初期値を`seed + i - 1`にします。randomize_seedが`true`の場合は無視されます。|
| play_reverse_duel        | bool         | --play_reverse_duel true               | play_reverse_duelについて に詳細を記載しています。 |
| workdir                  | string       | --workdir ./workdir                    | シミュレータが出力するファイルを出力するディレクトリを指定します |
| id                       | string       | --id SimA                              | シミュレータのコンソールログのヘッダを指定します。  複数起動する場合に別のidを付けると見分けが付きやすくなります。 |
| exit_with_udi            | bool         | --exit_with_udi true                   | python側が終了したり通信エラーが起こった際にシミュレータも終了します |
| duel_settings_path       | string       | --duel_settings_path duelSettings.json | デュエル開始時の状況を指定します。詳しくは**デュエル開始時のカード生成について**を参照してください。 | 
| connect                  | string       | --connect gRPC                         | python側との通信方法を指定します（`Socket`か`gRPC`） |
| grpc_deadline_seconds    | int          | --grpc_deadline_seconds 5              | gRPC通信のタイムアウト時間（秒）を指定します。 |
| udi_log_file             | string       | --udi_log_file udi_log_file.txt        | UDIからのログを出力するファイルを指定します。エラーが出て止まるときなどはこちらにファイル名を指定することでログを原因を調べることができる可能性があります。 |
| tcp_host0                | string       | --tcp_host0 127.0.0.1                  | プレイヤー0側のtcp_hostを指定します。 |
| tcp_port0                | int          | --tcp_port0 52010                      | プレイヤー0側のtcp_portを指定します。 |
| tcp_host1                | string       | --tcp_host1 127.0.0.1                  | プレイヤー1側のtcp_hostを指定します。 |
| tcp_port1                | int          | --tcp_port1 52011                      | プレイヤー1側のtcp_portを指定します。 |
| on_start_retry_connect_seconds | int    | --on_start_retry_connect_seconds 10    | UDIとの接続を待つ秒数を指定します。 |

#### デッキの形式について
deck_path0やdeck_path1で指定するデッキのjsonの形式は下記の様な構造になっています。

```
{
    "main": [
        1001,
        1002,
        1003,
        1004,
        ...
    ],
    "extra": []
}
```

`main`がメインデッキのcard_idの配列で、`extra`がエクストラデッキのcard_idの配列です。

card_idがどのカードを表すかは`libs/ygo/ygo/data/card_data.csv`を参照してください。

#### log_levelについて
シミュレータのコンソールに出力するログのレベルを指定できます。

数値が大きいほどログを出力しますが時間がかかってしまうので、動作確認では`3`にしておいて実際の学習では`2`か`1`を指定するのが良いかと思われます。

| レベル | 出力 |
|--------|------|
| 1     | 開始時の設定と終了時の結果のみを出力します。 |
| 2     | デュエルの進行中の簡易的なログのみを出力します。 |
| 3     | 盤面情報を含めた全てのログを出力します。 | 

#### play_reverse_duelについて
各seedについて、先攻後攻を逆にしてデュエルを行う設定です。

合計で`loop_num * 2`回のデュエルが行われることになります。

プレイヤー0とプレイヤー1のデッキが同じ場合は初期手札も同じになるので、プレイヤー0とプレイヤー1が同じ条件でデュエルを開始できます。

勝率を計算したいときなどはこちらを`true`にしておくと初期手札や先攻後攻による勝率のばらつきを抑えることができるかと思います。

### 設定方法について
シミュレータは起動時に同じディレクトリの`DuelSimulator/SimulatorSettings.json`を参照します。
このファイルを編集することで設定を変更できます。

`SimulatorSettings.json`は下記の様な構造になっています

```
{
  "player_type0": "Human",
  "player_type1": "CPU",
  "deck_path0": "DeckData/RoyaleBE.json",
  "deck_path1": "DeckData/RoyaleBE.json",
  "first_player": 0,
  "lp0": 8000,
  "lp1": 8000,
  "hand_num0": 5,
  "hand_num1": 5,
  "seed": 0,
  "log_level": 3,
  "loop_num": 3,
  "randomize_seed": false,
  "iterate_seed": false,
  "play_reverse_duel": true,
  "workdir": "./workdir",
  "id": "",
  "exit_with_udi": false,
  "duel_settings_path": "",
  "connect": "Socket",
  "grpc_deadline_seconds": 5,
  "udi_log_file": "",
  "tcp_host0": "127.0.0.1",
  "tcp_port0": 50001,
  "tcp_host1": "127.0.0.1",
  "tcp_port1": 50002,
  "on_start_retry_connect_seconds": 10
}
```

また、各設定項目は起動時のコマンドラインオプションで`SimulatorSettings.json`の設定は上書きする形で指定可能です。

コマンドラインオプションの指定の仕方は設定項目についての表を参照してください。

先述の実行手順の起動例ではこのコマンドラインオプションで設定を変更して起動しています。

## デュエル開始時のカード生成について

### 概要
シミュレータでは`duel_settings_path`を指定することでデュエル開始時に特定のカードが存在する状態でデュエルを始めることができます。

特定の状況でのAIの挙動確認やカードの効果発動確認をしたいときなどに利用できます。

### 指定の形式
カードの配置を記載したjsonによって開始時に生成されるカードを指定します。

以下はsampleのDuelSettings.jsonです。

```
{
    "debugCards": [
        {
            "cardId": 1004,
            "player": 0,
            "posId": 0,
            "cardIndex": 0,
            "face": 1,
            "turn": 1
        },
        {
            "cardId": 1013,
            "player": 1,
            "posId": 7,
            "cardIndex": 0,
            "face": 0,
            "turn": 0
        },
        {
            "cardId": 1010,
            "player": 0,
            "posId": 13,
            "cardIndex": 0,
            "face": 0,
            "turn": 0
        }
    ]
}
```

生成したいカードを`debugCards`に記入します。

この例の`debugCards`の一つ目の要素では、「青眼の白龍（`cardId = 1004`）」をプレイヤー0の左端のモンスターゾーン（`player = 0, posId = 0, cardIndex = 0`）に表側守備表示（`face = 1, turn = 1`）で生成しています。

### 各キーについて
`debugCards`の中身は生成するカードについての設定をする辞書です。

下記のキーで生成するカードを指定します。

| キー         | 型     | 説明 |
|--------------|-------|------|
| `cardId`     | int   | 生成するカードのcardId |
| `player`     | int   | カードを生成する場所のシミュレータでのプレイヤー番号。シミュレータでのプレイヤー番号なのでPlayerIdとは異なります。 |
| `posId`      | int   | カードを生成する場所のPosId。PosIdについてはygo.constants.PosIdを参照してください。 |
| `cardIndex`  | int   | カードを生成する場所のcardIndex。基本は0です。 |
| `face`       | int   | 生成するカードの表裏。`0` = 裏、`1` = 表 |
| `turn`       | int   | 生成するカードの縦横。`0` = 縦（攻撃表示）`1` = 横（守備表示） |

### 使用方法
設定項目のduel_settings_pathに用意したjsonファイルを指定します。

```
--duel_settings_path 用意したjsonのパス
```

### 利用上の注意
- こちらはマスターデュエルの方では扱えないシミュレータ限定の機能となります。
- 新たなカードが生成され実際のデュエルでは起こりえない状況とはなるため、シンプルな動作確認のために利用するのが良いかと思われます。
- 例えば魔法罠カードのturnを`1`で指定するなどで不整合を起こしてもエラーを返さないことがあるので、意図通り指定できているかは実行時に確認してください。